# Динамические и асинхронные компоненты

> Подразумевается, что уже изучили и разобрались с разделом [Основы компонентов](component-basics.md). Если нет — прочитайте его сначала.

## Динамические компоненты с `keep-alive`

Ранее в руководстве атрибут `is` использовался для переключения между компонентами в интерфейсе с вкладками:

```vue
<component :is="currentTabComponent"></component>
```

Но при переключении между компонентами может потребоваться сохранять их состояние или избежать перерисовки для производительности. Например, немного доработав пример:

<common-codepen-snippet title="Динамические компоненты: без использования keep-alive" slug="jOPjZOe" tab="html,result" />

Можно заметить, что выбрав пост, потом переключившись на вкладку _Archive_, а затем снова вернувшись на _Posts_, выбранный пост больше не отображается. Это происходит потому, что каждый раз, при переключении на другую вкладку Vue будет создавать новый экземпляр `currentTabComponent`.

Обычно пересоздание динамических компонентов полезно, но в данном случае хотелось бы чтобы экземпляры компонентов вкладок кэшировались после их создания в первый раз. Для решения этой проблемы динамический компонент можно обернуть в `<keep-alive>`:

```vue
<!-- Неактивные компоненты будут закэшированы! -->
<keep-alive>
  <component :is="currentTabComponent"></component>
</keep-alive>
```

Проверим результат:

<common-codepen-snippet title="Динамические компоненты: с использованием keep-alive" slug="VwLJQvP" tab="html,result" />

Теперь состояние (выбранный пост) на вкладке _Posts_ будет сохраняться даже тогда, когда она не отрисовывается.

Подробнее о компоненте `<keep-alive>` можно узнать в [справочнике API](../api/built-in-components.md#keep-alive).

## Асинхронные компоненты

В больших приложениях может потребоваться разделять приложение на меньшие части и загружать компоненты с сервера только когда они необходимы. Для реализации подобного Vue предоставляет метод `defineAsyncComponent`:

```js
const { createApp, defineAsyncComponent } = Vue

const app = createApp({})

const AsyncComp = defineAsyncComponent(
  () =>
    new Promise((resolve, reject) => {
      resolve({
        template: '<div>Асинхронный компонент!</div>'
      })
    })
)

app.component('async-example', AsyncComp)
```

Как видно, метод принимает функцию-фабрику, которая вернёт `Promise`. В Promise коллбэк `resolve` должен быть вызван, когда получено определение компонента с сервера. Кроме того, можно вызвать `reject(reason)` для обработки неудачной загрузки.

Также можно возвращать `Promise` из функции-фабрики, поэтому с Webpack 2 или более новой версии и синтаксисом ES2015 можно сделать так:

```js
import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() =>
  import('./components/AsyncComponent.vue')
)

app.component('async-component', AsyncComp)
```

Использовать `defineAsyncComponent` можно и при [локальной регистрации компонента](component-registration.md#локальная-регистрация):

```js
import { createApp, defineAsyncComponent } from 'vue'

createApp({
  // ...
  components: {
    AsyncComponent: defineAsyncComponent(() =>
      import('./components/AsyncComponent.vue')
    )
  }
})
```

### Использование с Suspense

Асинхронные компоненты по умолчанию считаются _suspensible_. Это значит, что при наличии `<Suspense>` в родительской цепочке, компонент будет рассматриваться как асинхронная зависимость от этого `<Suspense>`. В этом случае состояние загрузки контролируется `<Suspense>`, а собственные опции компонента для загрузки, ошибки и задержки таймаута игнорируются.

Асинхронный компонент может отказаться от управления `Suspense` и всегда использовать собственное состояние для загрузки, с помощью опции `suspensible: false`.

Список доступных опций можно посмотреть в [справочнике API](../api/global-api.md#аргументы-4)
